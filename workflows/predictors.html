<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4.4. Predictors &mdash; Citrine Python 2.19.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4.5. Design Spaces" href="design_spaces.html" />
    <link rel="prev" title="4.2. Descriptors" href="descriptors.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.19.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started/index.html">1. Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data_entry.html">2. GEMD Data Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data_extraction.html">3. Data Extraction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">4. AI Engine</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="getting_started.html">4.1. Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="descriptors.html">4.2. Descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="descriptors.html#platform-vocabularies">4.3. Platform Vocabularies</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.4. Predictors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#versioning">4.4.1. Versioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="#auto-ml-predictor">4.4.2. Auto ML predictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graph-predictor">4.4.3. Graph predictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">4.4.4. Expression predictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#molecular-structure-featurizer">4.4.5. Molecular Structure Featurizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#chemical-formula-featurizer">4.4.6. Chemical Formula Featurizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ingredients-to-formulation-predictor-alpha">4.4.7. Ingredients to formulation predictor (ALPHA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-mixture-predictor">4.4.8. Simple mixture predictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mean-property-predictor">4.4.9. Mean property predictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ingredient-fractions-predictor">4.4.10. Ingredient fractions predictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#label-fractions-predictor">4.4.11. Label fractions predictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-ml-predictor">4.4.12. Simple ML predictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#predictor-reports">4.4.13. Predictor reports</a></li>
<li class="toctree-l3"><a class="reference internal" href="#training-data">4.4.14. Training data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#single-predictions">4.4.15. Single Predictions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="design_spaces.html">4.5. Design Spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="design_workflows.html">4.6. Design Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="scores.html">4.7. Scores</a></li>
<li class="toctree-l2"><a class="reference internal" href="data_sources.html">4.8. Data Sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="predictor_reports.html">4.9. Predictor Reports</a></li>
<li class="toctree-l2"><a class="reference internal" href="predictor_evaluation_workflows.html">4.10. Predictor Evaluation Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="code_examples.html">4.11. AI Engine Code Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../formulations_example.html">5. Formulations Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../molecular_generation.html">6. [ALPHA] Generative Design Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../FAQ/index.html">7. FAQ</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Citrine Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html"><span class="section-number">4. </span>AI Engine</a> &raquo;</li>
      <li><span class="section-number">4.4. </span>Predictors</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/workflows/predictors.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="predictors">
<span id="id1"></span><h1><span class="section-number">4.4. </span>Predictors<a class="headerlink" href="#predictors" title="Permalink to this headline"></a></h1>
<p>A predictor computes or predicts properties of materials.
All predictors take one or more <a class="reference internal" href="descriptors.html"><span class="doc">descriptors</span></a> as inputs and produce one or more output descriptors.
Types of predictors include machine learning models, featurizers, and analytic expressions.</p>
<p>A predictor must be registered to a project to be used in a <a class="reference internal" href="design_workflows.html"><span class="doc">design workflow</span></a>.</p>
<section id="versioning">
<h2><span class="section-number">4.4.1. </span>Versioning<a class="headerlink" href="#versioning" title="Permalink to this headline"></a></h2>
<p>All predictors have a version number. When you create a new predictor, it will be version 1, and its <cite>draft</cite> flag will be <cite>True</cite>.
While <cite>draft</cite> is True, any edits will overwrite the current version.
Once the predictor trains successfully, <cite>draft</cite> will be set to <cite>False</cite>. Any further edits will apply to the next version.
If training fails, <cite>draft</cite> will remain <cite>True</cite>.
To act on a specific version of the predictor (where allowed), use the function which accepts a <cite>version</cite> argument.
Any which don’t accept a version act on the most recent version of the predictor. For example, <cite>get()</cite> vs. <cite>get_version()</cite>.</p>
</section>
<section id="auto-ml-predictor">
<h2><span class="section-number">4.4.2. </span>Auto ML predictor<a class="headerlink" href="#auto-ml-predictor" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../reference/citrine.informatics.predictors.auto_ml_predictor.html#citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor" title="citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoMLPredictor</span></code></a> predicts material properties using a machine-learned model.
AutoMLPredictors allow you to use your domain knowledge to construct custom <a class="reference external" href="#graph-predictor">GraphPredictors</a> with fine grain control over the resulting graph.
Each AutoMLPredictor is defined by a set of inputs and outputs.
Inputs are used as input features to the machine learning model.
The outputs are the properties that you would like the model to predict.
Currently, only one output per AutoML predictor is supported, and there must be at least one input.
Unlike the <a class="reference external" href="#simple-ml-predictor">SimpleMLPredictor</a>, only one model is trained from inputs to the outputs.</p>
<p>AutoMLPredictors support both regression and classification.
For each <a class="reference internal" href="../reference/citrine.informatics.descriptors.html#citrine.informatics.descriptors.RealDescriptor" title="citrine.informatics.descriptors.RealDescriptor"><code class="xref py py-class docutils literal notranslate"><span class="pre">RealDescriptor</span></code></a> output, regression is performed.
For each <a class="reference internal" href="../reference/citrine.informatics.descriptors.html#citrine.informatics.descriptors.CategoricalDescriptor" title="citrine.informatics.descriptors.CategoricalDescriptor"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalDescriptor</span></code></a> output, classification is performed.
Both binary and multi-class classification are supported automatically based on the number of categories in the data.</p>
<p>Models are trained using data provided by a <a class="reference internal" href="../reference/citrine.informatics.data_sources.html#citrine.informatics.data_sources.DataSource" title="citrine.informatics.data_sources.DataSource"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataSource</span></code></a> specified when creating a predictor.
The inputs and outputs are descriptors, which must correspond precisely to descriptors that exist in the training data or are produced by other predictors in the graphical model.
There are two important helper methods in this regard.
<a class="reference internal" href="../reference/citrine.resources.descriptors.html#citrine.resources.descriptors.DescriptorMethods.descriptors_from_data_source" title="citrine.resources.descriptors.DescriptorMethods.descriptors_from_data_source"><code class="xref py py-func docutils literal notranslate"><span class="pre">descriptors_from_data_source()</span></code></a> can provide all of the descriptors that are present in the training data.
<a class="reference internal" href="../reference/citrine.resources.descriptors.html#citrine.resources.descriptors.DescriptorMethods.from_predictor_responses" title="citrine.resources.descriptors.DescriptorMethods.from_predictor_responses"><code class="xref py py-func docutils literal notranslate"><span class="pre">from_predictor_responses()</span></code></a> can tell you what the outputs of a predictor will be, which is especially useful for featurizers.</p>
<p>The following example demonstrates how to use the Citrine Python client to create an <a class="reference internal" href="../reference/citrine.informatics.predictors.auto_ml_predictor.html#citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor" title="citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoMLPredictor</span></code></a>, register the predictor to a project and wait for validation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">AutoMLPredictor</span>
<span class="kn">from</span> <span class="nn">citrine.seeding.find_or_create</span> <span class="kn">import</span> <span class="n">create_or_update</span>

<span class="c1"># create AutoMLPredictor (assumes descriptors for</span>
<span class="c1"># inputs/output variables have already been created)</span>
<span class="n">auto_ml_predictor</span> <span class="o">=</span> <span class="n">AutoMLPredictor</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Predictor name&#39;</span><span class="p">,</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;Predictor description&#39;</span><span class="p">,</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_descriptor_1</span><span class="p">,</span> <span class="n">input_descriptor_2</span><span class="p">],</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_descriptor_1</span><span class="p">],</span>
    <span class="n">training_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">GemTableDataSource</span><span class="p">(</span><span class="n">table_id</span><span class="o">=</span><span class="n">training_data_table_uid</span><span class="p">,</span> <span class="n">table_version</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
<span class="p">)</span>

<span class="n">predictor</span> <span class="o">=</span> <span class="n">create_or_update</span><span class="p">(</span><span class="n">collection</span><span class="o">=</span><span class="n">project</span><span class="o">.</span><span class="n">predictors</span><span class="p">,</span>
                             <span class="n">resource</span><span class="o">=</span><span class="n">auto_ml_predictor</span>
                            <span class="p">)</span>
</pre></div>
</div>
</section>
<section id="graph-predictor">
<h2><span class="section-number">4.4.3. </span>Graph predictor<a class="headerlink" href="#graph-predictor" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../reference/citrine.informatics.predictors.graph_predictor.html#citrine.informatics.predictors.graph_predictor.GraphPredictor" title="citrine.informatics.predictors.graph_predictor.GraphPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphPredictor</span></code></a> stitches together multiple predictors into a directed bipartite graph.
The predictors are connected based on their descriptors – using a descriptor as the output of one predictor and also as the input of another will ensure that the predictors are wired together.
The graph structure is quite flexible.
A descriptor can be the output and/or input of multiple predictors, and cycles are permitted.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">GraphPredictor</span></code> is created by specifying the sub-predictors.
These can either be references to predictors that exist on-platform, or they can be predictors that are defined locally.
A sub-predictor <strong>cannot</strong> be another <code class="docutils literal notranslate"><span class="pre">GraphPredictor</span></code>.</p>
<p>Training data can be specified when creating a graph predictor.
This will be combined with any training data present in the sub-predictors.</p>
<p>The following example demonstrates how to create a <a class="reference internal" href="../reference/citrine.informatics.predictors.graph_predictor.html#citrine.informatics.predictors.graph_predictor.GraphPredictor" title="citrine.informatics.predictors.graph_predictor.GraphPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphPredictor</span></code></a> from on-platform and locally-defined predictors.
Assume that there exists a CSV file with columns for time, bulk modulus, and Poisson’s ratio.
We train ML models to predict bulk modulus and Poisson’s ratio, then apply an expression to calculate Young’s modulus.
The ML models are independently registered on-platform, but the expression predictor is defined locally and hence cannot be re-used.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">GraphPredictor</span><span class="p">,</span> <span class="n">AutoMLPredictor</span><span class="p">,</span> <span class="n">ExpressionPredictor</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.data_sources</span> <span class="kn">import</span> <span class="n">CSVDataSource</span>

<span class="n">time</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="s2">&quot;tempering time&quot;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
<span class="n">bulk_modulus</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="s2">&quot;Bulk Modulus&quot;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mf">1E3</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;GPa&quot;</span><span class="p">)</span>
<span class="n">poissons_ratio</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="s2">&quot;Poisson</span><span class="se">\&#39;</span><span class="s2">s Ratio&quot;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">training_data</span> <span class="o">=</span> <span class="n">CSVDataSource</span><span class="p">(</span>
    <span class="n">file_link</span> <span class="o">=</span> <span class="n">elastic_properties_file</span><span class="p">,</span>
    <span class="n">column_definition</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Tempering Time (s)&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
        <span class="s2">&quot;Bulk Modulus (GPa)&quot;</span><span class="p">:</span> <span class="n">bulk_modulus</span><span class="p">,</span>
        <span class="s2">&quot;Poisson</span><span class="se">\&#39;</span><span class="s2">s Ratio&quot;</span><span class="p">:</span> <span class="n">poissons_ratio</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="n">bulk_modulus_predictor</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">AutoMLPredictor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;predict bulk modulus from tempering time&quot;</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">time</span><span class="p">],</span>
        <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">bulk_modulus</span><span class="p">],</span>
        <span class="n">training_data</span><span class="o">=</span><span class="p">[</span><span class="n">training_data</span><span class="p">]</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="n">poissons_ratio_predictor</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">AutoMLPredictor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;predict Poisson</span><span class="se">\&#39;</span><span class="s2">s ratio from tempering time&quot;</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">time</span><span class="p">],</span>
        <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">poissons_ratio</span><span class="p">],</span>
        <span class="n">training_data</span><span class="o">=</span><span class="p">[</span><span class="n">training_data</span><span class="p">]</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="n">youngs_modulus</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="s2">&quot;Young</span><span class="se">\&#39;</span><span class="s2">s Modulus&quot;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mf">1E4</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;GPa&quot;</span><span class="p">)</span>
<span class="n">expression_predictor</span> <span class="o">=</span> <span class="n">ExpressionPredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Young</span><span class="se">\&#39;</span><span class="s2">s modulus from bulk modulus and Poisson&#39;s ratio&quot;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">expression</span><span class="o">=</span><span class="s2">&quot;3 * K * (1 - 2 * eta)&quot;</span><span class="p">,</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">youngs_modulus</span><span class="p">],</span>
    <span class="n">aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;K&quot;</span><span class="p">:</span> <span class="n">bulk_modulus</span><span class="p">,</span> <span class="s2">&quot;eta&quot;</span><span class="p">:</span> <span class="n">poissons_ratio</span><span class="p">}</span>
<span class="p">)</span>

<span class="n">graph_predictor</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">GraphPredictor</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Big elastic constant predictor,</span>
        <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">predictors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">bulk_modulus_predictor</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span>
            <span class="n">poissons_ratio_predictor</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span>
            <span class="n">expression_predictor</span>
        <span class="p">],</span>
       <span class="n">training_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>For another example of graph predictor usage, see <a class="reference internal" href="code_examples.html#graph-predictor-example"><span class="std std-ref">AI Engine Code Examples</span></a>.</p>
</section>
<section id="id2">
<h2><span class="section-number">4.4.4. </span>Expression predictor<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../reference/citrine.informatics.predictors.expression_predictor.html#citrine.informatics.predictors.expression_predictor.ExpressionPredictor" title="citrine.informatics.predictors.expression_predictor.ExpressionPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExpressionPredictor</span></code></a> defines an analytic (lossless) model that computes one real-valued output descriptor from one or more input descriptors.
An <a class="reference internal" href="../reference/citrine.informatics.predictors.expression_predictor.html#citrine.informatics.predictors.expression_predictor.ExpressionPredictor" title="citrine.informatics.predictors.expression_predictor.ExpressionPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExpressionPredictor</span></code></a> should be used when the relationship between inputs and outputs is known.</p>
<p>A string is used to define the expression, and the corresponding output is defined by a <a class="reference internal" href="../reference/citrine.informatics.descriptors.html#citrine.informatics.descriptors.RealDescriptor" title="citrine.informatics.descriptors.RealDescriptor"><code class="xref py py-class docutils literal notranslate"><span class="pre">RealDescriptor</span></code></a>.
An alias is required for each expression argument.
The <code class="docutils literal notranslate"><span class="pre">aliases</span></code> parameter defines a mapping from expression arguments to their associated input descriptors.
The expression argument does not need to match its descriptor key.
This is useful to avoid typing out the verbose descriptor keys in the expression string.
Note, spaces are not supported in expression arguments, e.g., <code class="docutils literal notranslate"><span class="pre">Y</span></code> is a valid argument while <code class="docutils literal notranslate"><span class="pre">Young's</span> <span class="pre">modulus</span></code> is not.</p>
<p>The syntax is described in the <a class="reference external" href="http://mathparser.org/mxparser-math-collection">mXparser documentation</a>.
Citrine-python currently supports the following operators and functions:</p>
<ul class="simple">
<li><p>basic operators: addition <code class="docutils literal notranslate"><span class="pre">+</span></code>, subtraction <code class="docutils literal notranslate"><span class="pre">-</span></code>, multiplication <code class="docutils literal notranslate"><span class="pre">*</span></code>, division <code class="docutils literal notranslate"><span class="pre">/</span></code>, exponentiation <code class="docutils literal notranslate"><span class="pre">^</span></code></p></li>
<li><p>built-in math functions:</p>
<ul>
<li><p>trigonometric (input in radians): <code class="docutils literal notranslate"><span class="pre">sin</span></code>, <code class="docutils literal notranslate"><span class="pre">cos</span></code>, <code class="docutils literal notranslate"><span class="pre">tan</span></code>, <code class="docutils literal notranslate"><span class="pre">asin</span></code>, <code class="docutils literal notranslate"><span class="pre">acos</span></code>, <code class="docutils literal notranslate"><span class="pre">atan</span></code></p></li>
<li><p>hyperbolic: <code class="docutils literal notranslate"><span class="pre">sinh</span></code>, <code class="docutils literal notranslate"><span class="pre">cosh</span></code>, <code class="docutils literal notranslate"><span class="pre">tanh</span></code></p></li>
<li><p>logarithm: <code class="docutils literal notranslate"><span class="pre">log10</span></code>, <code class="docutils literal notranslate"><span class="pre">ln</span></code></p></li>
<li><p>exponential: <code class="docutils literal notranslate"><span class="pre">exp</span></code></p></li>
</ul>
</li>
<li><p>constants: <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">e</span></code></p></li>
<li><p>if statements: <code class="docutils literal notranslate"><span class="pre">if(condition,</span> <span class="pre">value_if_true,</span> <span class="pre">value_if_false)</span></code></p></li>
</ul>
<p>ExpressionPredictors do not support complex numbers.</p>
<p>The following example demonstrates how to create an <a class="reference internal" href="../reference/citrine.informatics.predictors.expression_predictor.html#citrine.informatics.predictors.expression_predictor.ExpressionPredictor" title="citrine.informatics.predictors.expression_predictor.ExpressionPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExpressionPredictor</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">ExpressionPredictor</span>

<span class="n">youngs_modulus</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;Property~Young</span><span class="se">\&#39;</span><span class="s1">s modulus&#39;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;GPa&#39;</span><span class="p">)</span>
<span class="n">poissons_ratio</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;Property~Poisson</span><span class="se">\&#39;</span><span class="s1">s ratio&#39;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">shear_modulus</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;Property~Shear modulus&#39;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;GPa&#39;</span><span class="p">)</span>

<span class="n">shear_modulus_predictor</span> <span class="o">=</span> <span class="n">ExpressionPredictor</span><span class="p">(</span>
   <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Shear modulus predictor&#39;</span><span class="p">,</span>
   <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;Computes shear modulus from Young&#39;s modulus and Poisson&#39;s ratio.&quot;</span><span class="p">,</span>
   <span class="n">expression</span> <span class="o">=</span> <span class="s1">&#39;Y / (2 * (1 + v))&#39;</span><span class="p">,</span>
   <span class="n">output</span> <span class="o">=</span> <span class="n">shear_modulus</span><span class="p">,</span>
   <span class="n">aliases</span> <span class="o">=</span> <span class="p">{</span>
       <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">youngs_modulus</span><span class="p">,</span>
       <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="n">poissons_ratio</span>
   <span class="p">}</span>
<span class="p">)</span>

<span class="c1"># register or update predictor by name</span>
<span class="n">predictor</span> <span class="o">=</span> <span class="n">create_or_update</span><span class="p">(</span>
    <span class="n">collection</span><span class="o">=</span><span class="n">project</span><span class="o">.</span><span class="n">predictors</span><span class="p">,</span>
    <span class="n">module</span><span class="o">=</span><span class="n">shear_modulus_predictor</span>
<span class="p">)</span>
</pre></div>
</div>
<p>For an example of expression predictors used in a graph predictor, see <a class="reference internal" href="code_examples.html#graph-predictor-example"><span class="std std-ref">AI Engine Code Examples</span></a>.</p>
</section>
<section id="molecular-structure-featurizer">
<h2><span class="section-number">4.4.5. </span>Molecular Structure Featurizer<a class="headerlink" href="#molecular-structure-featurizer" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../reference/citrine.informatics.predictors.molecular_structure_featurizer.html#citrine.informatics.predictors.molecular_structure_featurizer.MolecularStructureFeaturizer" title="citrine.informatics.predictors.molecular_structure_featurizer.MolecularStructureFeaturizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularStructureFeaturizer</span></code></a>
computes a configurable set of features on molecular structure data, e.g., SMILES or InChI strings, using the <a class="reference external" href="https://cdk.github.io/">Chemistry Development Kit (CDK)</a>.
The features are configured using the <code class="docutils literal notranslate"><span class="pre">features</span></code> and <code class="docutils literal notranslate"><span class="pre">excludes</span></code> arguments, which accept either feature names or predefined aliases.
The default is the <cite>standard</cite> alias, corresponding to eight features that are a good balance of cost and performance.</p>
<p>The feature names and descriptors are automatically constructed from the name of the input and the feature names.
The <code class="docutils literal notranslate"><span class="pre">from_predictor_responses</span></code> method will grab the descriptors for the features so that they can be fed into other predicors,
e.g., the <a class="reference internal" href="../reference/citrine.informatics.predictors.auto_ml_predictor.html#citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor" title="citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoMLPredictor</span></code></a>, as inputs.</p>
<p>The following example demonstrates how to use a <a class="reference internal" href="../reference/citrine.informatics.predictors.molecular_structure_featurizer.html#citrine.informatics.predictors.molecular_structure_featurizer.MolecularStructureFeaturizer" title="citrine.informatics.predictors.molecular_structure_featurizer.MolecularStructureFeaturizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularStructureFeaturizer</span></code></a> and
<a class="reference internal" href="../reference/citrine.informatics.predictors.auto_ml_predictor.html#citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor" title="citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoMLPredictor</span></code></a> to model a property of a molecule:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.descriptors</span> <span class="kn">import</span> <span class="n">MolecularStructureDescriptor</span><span class="p">,</span> <span class="n">RealDescriptor</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">MolecularStructureFeaturizer</span><span class="p">,</span> <span class="n">AutoMLPredictor</span><span class="p">,</span> <span class="n">GraphPredictor</span>
<span class="kn">from</span> <span class="nn">citrine.seeding.find_or_create</span> <span class="kn">import</span> <span class="n">create_or_update</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.data_sources</span> <span class="kn">import</span> <span class="n">GemTableDataSource</span>


<span class="c1"># descriptor for the molecular structure input</span>
<span class="n">input_desc</span> <span class="o">=</span> <span class="n">MolecularStructureDescriptor</span><span class="p">(</span><span class="s1">&#39;Solvent SMILES&#39;</span><span class="p">)</span>
<span class="c1"># descriptor for the property to define a machine learning model to predict</span>
<span class="n">output_desc</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span>
    <span class="n">key</span><span class="o">=</span><span class="s2">&quot;density&quot;</span><span class="p">,</span>
    <span class="n">units</span><span class="o">=</span><span class="s2">&quot;g/cm^3&quot;</span><span class="p">,</span>
    <span class="n">lower_bound</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">upper_bound</span><span class="o">=</span><span class="mf">100.0</span>
<span class="p">)</span>


<span class="c1"># featurize the molecular structure</span>
<span class="n">featurizer</span> <span class="o">=</span> <span class="n">MolecularStructureFeaturizer</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Molecular Featurizer&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Featurize the Solvent&#39;s molecular structure using the default features.&quot;</span><span class="p">,</span>
    <span class="n">input_descriptor</span><span class="o">=</span><span class="n">input_desc</span><span class="p">,</span>
    <span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;standard&#39;</span><span class="p">],</span>
<span class="p">)</span>

<span class="c1"># get the feature names</span>
<span class="n">features</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">descriptors</span><span class="o">.</span><span class="n">from_predictor_responses</span><span class="p">(</span>
    <span class="n">predictor</span><span class="o">=</span><span class="n">featurizer</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">input_desc</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1"># create AutoMLPredictor, using the feature names as inputs</span>
<span class="c1"># note: the molecular structure, `input_desc`, should not be included in the inputs here</span>
<span class="n">ml_predictor</span> <span class="o">=</span> <span class="n">AutoMLPredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ML Model for Density&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Predict the density, given molecular features of the solvent&#39;</span><span class="p">,</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">features</span><span class="p">,</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_desc</span><span class="p">],</span>
    <span class="n">training_data</span> <span class="o">=</span> <span class="p">[]</span>
<span class="p">)</span>

<span class="c1"># use a graph predictor to wrap together the featurizer and the machine learning model</span>
<span class="n">graph_predictor</span> <span class="o">=</span> <span class="n">GraphPredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Density from solvent molecular structure&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Predict the density from the solvent molecular structure using molecular structure features.&#39;</span><span class="p">,</span>
    <span class="n">predictors</span> <span class="o">=</span> <span class="p">[</span><span class="n">featurizer</span><span class="p">,</span> <span class="n">ml_predictor</span><span class="p">],</span>
    <span class="n">training_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">GemTableDataSource</span><span class="p">(</span><span class="n">table_id</span><span class="o">=</span><span class="n">training_data_table_uid</span><span class="p">,</span> <span class="n">table_version</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># training data shared by all sub-predictors</span>
<span class="p">)</span>

<span class="c1"># register or update predictor by name</span>
<span class="n">predictor</span> <span class="o">=</span> <span class="n">create_or_update</span><span class="p">(</span>
    <span class="n">collection</span><span class="o">=</span><span class="n">project</span><span class="o">.</span><span class="n">predictors</span><span class="p">,</span>
    <span class="n">module</span><span class="o">=</span><span class="n">graph_predictor</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="chemical-formula-featurizer">
<h2><span class="section-number">4.4.6. </span>Chemical Formula Featurizer<a class="headerlink" href="#chemical-formula-featurizer" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../reference/citrine.informatics.predictors.chemical_formula_featurizer.html#citrine.informatics.predictors.chemical_formula_featurizer.ChemicalFormulaFeaturizer" title="citrine.informatics.predictors.chemical_formula_featurizer.ChemicalFormulaFeaturizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChemicalFormulaFeaturizer</span></code></a>
computes a configurable set of features on chemical formula data by using the properties of the individual elements
and their stoichiometric amounts.
Many of the features are stoichiometrically weighted generalized means of element-level properties, though some are more complex functions of the chemical formula.
The generalized means are configured with the <code class="docutils literal notranslate"><span class="pre">powers</span></code> argument, which is a list of means to calculate.
For example, setting <code class="docutils literal notranslate"><span class="pre">powers=[1,</span> <span class="pre">3]</span></code> will calculate the mean and 3-mean of all applicable features.</p>
<p>The features to compute are configured using the <code class="docutils literal notranslate"><span class="pre">features</span></code> and <code class="docutils literal notranslate"><span class="pre">excludes</span></code> arguments, which accept either feature names or predefined aliases.
The default is the <cite>standard</cite> alias, corresponding to a variety of features that are intuitive and often correlate with properties of interest.
Other aliases are “physical,” “electronic,” and “periodicTable.”
A complete list of features and which aliases they map to can be found in the class docstring.</p>
<p>The feature names and descriptors are automatically constructed from the name of the input and the feature names.
The <code class="docutils literal notranslate"><span class="pre">from_predictor_responses</span></code> method will grab the descriptors for the features so that they can be fed into other predicors,
e.g., the <a class="reference internal" href="../reference/citrine.informatics.predictors.auto_ml_predictor.html#citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor" title="citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoMLPredictor</span></code></a>, as inputs.</p>
<p>The following example demonstrates how to use a <a class="reference internal" href="../reference/citrine.informatics.predictors.chemical_formula_featurizer.html#citrine.informatics.predictors.chemical_formula_featurizer.ChemicalFormulaFeaturizer" title="citrine.informatics.predictors.chemical_formula_featurizer.ChemicalFormulaFeaturizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChemicalFormulaFeaturizer</span></code></a> and
<a class="reference internal" href="../reference/citrine.informatics.predictors.auto_ml_predictor.html#citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor" title="citrine.informatics.predictors.auto_ml_predictor.AutoMLPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoMLPredictor</span></code></a> to model a property of an alloy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.descriptors</span> <span class="kn">import</span> <span class="n">ChemicalFormulaDescriptor</span><span class="p">,</span> <span class="n">RealDescriptor</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">ChemicalFormulaFeaturizer</span><span class="p">,</span> <span class="n">AutoMLPredictor</span><span class="p">,</span> <span class="n">GraphPredictor</span>
<span class="kn">from</span> <span class="nn">citrine.seeding.find_or_create</span> <span class="kn">import</span> <span class="n">create_or_update</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.data_sources</span> <span class="kn">import</span> <span class="n">GemTableDataSource</span>


<span class="c1"># descriptor for the chemical formula input</span>
<span class="n">input_desc</span> <span class="o">=</span> <span class="n">ChemicalFormulaDescriptor</span><span class="p">(</span><span class="s1">&#39;Alloy chemical formula&#39;</span><span class="p">)</span>
<span class="c1"># descriptor for the property to define a machine learning model to predict</span>
<span class="n">output_desc</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span>
    <span class="n">key</span><span class="o">=</span><span class="s2">&quot;melting temperature&quot;</span><span class="p">,</span>
    <span class="n">units</span><span class="o">=</span><span class="s2">&quot;Kelvin&quot;</span><span class="p">,</span>
    <span class="n">lower_bound</span><span class="o">=</span><span class="mf">300.0</span><span class="p">,</span>
    <span class="n">upper_bound</span><span class="o">=</span><span class="mf">5000.0</span>
<span class="p">)</span>


<span class="c1"># featurize the chemical formula</span>
<span class="n">featurizer</span> <span class="o">=</span> <span class="n">ChemicalFormulaFeaturizer</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ChemicalFeaturizer&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Featurize the Alloy&#39;s chemical formula using the default features and a 2-mean.&quot;</span><span class="p">,</span>
    <span class="n">input_descriptor</span><span class="o">=</span><span class="n">input_desc</span><span class="p">,</span>
    <span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;standard&#39;</span><span class="p">],</span>
    <span class="n">powers</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1"># get the feature names</span>
<span class="n">features</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">descriptors</span><span class="o">.</span><span class="n">from_predictor_responses</span><span class="p">(</span>
    <span class="n">predictor</span><span class="o">=</span><span class="n">featurizer</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">input_desc</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1"># create AutoMLPredictor, using the feature names as inputs</span>
<span class="c1"># note: the chemical formula, `input_desc`, should not be included in the inputs here</span>
<span class="n">ml_predictor</span> <span class="o">=</span> <span class="n">AutoMLPredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ML Model for Melting Temperature&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Predict the melting temperature, given chemical features of the alloy&#39;</span><span class="p">,</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">features</span><span class="p">,</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_desc</span><span class="p">],</span>
    <span class="n">training_data</span> <span class="o">=</span> <span class="p">[]</span>
<span class="p">)</span>

<span class="c1"># use a graph predictor to wrap together the featurizer and the machine learning model</span>
<span class="n">graph_predictor</span> <span class="o">=</span> <span class="n">GraphPredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Melting temperature from alloy chemical formula&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Predict the melting temperature from the alloy chemical formula using chemical formula features.&#39;</span><span class="p">,</span>
    <span class="n">predictors</span> <span class="o">=</span> <span class="p">[</span><span class="n">featurizer</span><span class="p">,</span> <span class="n">ml_predictor</span><span class="p">],</span>
    <span class="n">training_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">GemTableDataSource</span><span class="p">(</span><span class="n">table_id</span><span class="o">=</span><span class="n">training_data_table_uid</span><span class="p">,</span> <span class="n">table_version</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># training data shared by all sub-predictors</span>
<span class="p">)</span>

<span class="c1"># register or update predictor by name</span>
<span class="n">predictor</span> <span class="o">=</span> <span class="n">create_or_update</span><span class="p">(</span>
    <span class="n">collection</span><span class="o">=</span><span class="n">project</span><span class="o">.</span><span class="n">predictors</span><span class="p">,</span>
    <span class="n">module</span><span class="o">=</span><span class="n">graph_predictor</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="ingredients-to-formulation-predictor-alpha">
<h2><span class="section-number">4.4.7. </span>Ingredients to formulation predictor (ALPHA)<a class="headerlink" href="#ingredients-to-formulation-predictor-alpha" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../reference/citrine.informatics.predictors.ingredients_to_formulation_predictor.html#citrine.informatics.predictors.ingredients_to_formulation_predictor.IngredientsToFormulationPredictor" title="citrine.informatics.predictors.ingredients_to_formulation_predictor.IngredientsToFormulationPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">IngredientsToFormulationPredictor</span></code></a> constructs a formulation from a list of ingredients.
This predictor is only required to construct formulations from CSV data sources.
Formulations are constructed automatically by GEM Tables when the underlying GEMD data contains formulations, so
an <a class="reference internal" href="../reference/citrine.informatics.predictors.ingredients_to_formulation_predictor.html#citrine.informatics.predictors.ingredients_to_formulation_predictor.IngredientsToFormulationPredictor" title="citrine.informatics.predictors.ingredients_to_formulation_predictor.IngredientsToFormulationPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">IngredientsToFormulationPredictor</span></code></a> is not required in those cases.</p>
<p>Ingredients are specified by a map from ingredient id to the descriptor that contains the ingredient’s quantity.
For example, <code class="docutils literal notranslate"><span class="pre">{'water':</span> <span class="pre">RealDescriptor('water</span> <span class="pre">quantity',</span> <span class="pre">lower_bound=0,</span> <span class="pre">upper_bound=1,</span> <span class="pre">units='')}</span></code> defines an ingredient <code class="docutils literal notranslate"><span class="pre">water</span></code> with quantity held by the descriptor <code class="docutils literal notranslate"><span class="pre">water</span> <span class="pre">quantity</span></code>.
There must be a corresponding (id, quantity) pair in the map for all possible ingredients.
If a material does not contain data for a given quantity descriptor key, it is assumed that ingredient is not present in the mixture.</p>
<p>Let’s add another ingredient <code class="docutils literal notranslate"><span class="pre">salt</span></code> to our map and say we are given data in the form:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 24%" />
<col style="width: 23%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Ingredient id</p></th>
<th class="head"><p>water quantity</p></th>
<th class="head"><p>salt quantity</p></th>
<th class="head"><p>density (g/cc)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>hypertonic saline</p></td>
<td><p>0.93</p></td>
<td><p>0.07</p></td>
<td><p>1.08</p></td>
</tr>
<tr class="row-odd"><td><p>isotonic saline</p></td>
<td><p>0.99</p></td>
<td><p>0.01</p></td>
<td><p>1.01</p></td>
</tr>
<tr class="row-even"><td><p>water</p></td>
<td></td>
<td></td>
<td><p>1.0</p></td>
</tr>
<tr class="row-odd"><td><p>salt</p></td>
<td></td>
<td></td>
<td><p>2.16</p></td>
</tr>
</tbody>
</table>
<p>There are two mixtures, hypertonic and isotonic saline, formed by mixing water and salt together in different amounts.
(Note, water and salt are leaf ingredients; hence these rows do not contain quantity data.)
Mixtures are defined by a map from ingredient id to quantity, so this predictor would form 2 mixtures with recipes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># hypertonic saline</span>
<span class="p">{</span><span class="s1">&#39;water&#39;</span><span class="p">:</span> <span class="mf">0.93</span><span class="p">,</span> <span class="s1">&#39;salt&#39;</span><span class="p">:</span> <span class="mf">0.07</span><span class="p">}</span>

<span class="c1"># isotonic saline</span>
<span class="p">{</span><span class="s1">&#39;water&#39;</span><span class="p">:</span> <span class="mf">0.99</span><span class="p">,</span> <span class="s1">&#39;salt&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>
</pre></div>
</div>
<p>Ingredients may be given 0 or more labels.
Labels provide a way to group or distinguish one or more ingredients and can be used to featurize mixtures (discussed in the next section).
The same label may be given to multiple ingredients, and a single ingredient may be given multiple labels.
Labels are specified using a map from each label to a list of all ingredients that should be given that label.
Anytime a recipe contains a non-zero amount of labeled ingredient, the ingredient is assigned the label.
For example, we may wish to label <code class="docutils literal notranslate"><span class="pre">water</span></code> as a solvent and <code class="docutils literal notranslate"><span class="pre">salt</span></code> as a solute.
These labels are specified via:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;solvent&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;water&quot;</span><span class="p">},</span> <span class="s2">&quot;solute&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;salt&quot;</span><span class="p">}}</span>
</pre></div>
</div>
<p>The following example illustrates how an
<a class="reference internal" href="../reference/citrine.informatics.predictors.ingredients_to_formulation_predictor.html#citrine.informatics.predictors.ingredients_to_formulation_predictor.IngredientsToFormulationPredictor" title="citrine.informatics.predictors.ingredients_to_formulation_predictor.IngredientsToFormulationPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">IngredientsToFormulationPredictor</span></code></a>
is constructed for the saline example.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.descriptors</span> <span class="kn">import</span> <span class="n">FormulationDescriptor</span><span class="p">,</span> <span class="n">RealDescriptor</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">IngredientsToFormulationPredictor</span>

<span class="n">file_link</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">upload</span><span class="p">(</span><span class="n">file_path</span><span class="o">=</span><span class="s2">&quot;./saline_solutions.csv&quot;</span><span class="p">,</span> <span class="n">dest_name</span><span class="s2">&quot;saline_solutions.csv&quot;</span><span class="p">)</span>

<span class="c1"># create descriptors for each ingredient quantity (volume fraction)</span>
<span class="n">water_quantity</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;water quantity&#39;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">salt_quantity</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;salt quantity&#39;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

<span class="c1"># create a descriptor to hold density data</span>
<span class="n">density</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;g/cc&#39;</span><span class="p">)</span>

<span class="n">data_source</span> <span class="o">=</span> <span class="n">CSVDataSource</span><span class="p">(</span>
    <span class="n">file_link</span> <span class="o">=</span> <span class="n">file_link</span><span class="p">,</span>
    <span class="n">column_definitions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;water quantity&#39;</span><span class="p">:</span> <span class="n">water_quantity</span><span class="p">,</span>
        <span class="s1">&#39;salt quantity&#39;</span><span class="p">:</span> <span class="n">salt_quantity</span><span class="p">,</span>
        <span class="s1">&#39;density&#39;</span><span class="p">:</span> <span class="n">density</span>
    <span class="p">},</span>
    <span class="n">identifiers</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ingredient id&#39;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">IngredientsToFormulationPredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Ingredients to formulation predictor&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Constructs a mixture from ingredient quantities&#39;</span><span class="p">,</span>
    <span class="c1"># map from ingredient id to its quantity</span>
    <span class="n">id_to_quantity</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;water&#39;</span><span class="p">:</span> <span class="n">water_quantity</span><span class="p">,</span>
        <span class="s1">&#39;salt&#39;</span><span class="p">:</span> <span class="n">salt_quantity</span>
    <span class="p">},</span>
    <span class="c1"># label water as a solvent and salt a solute</span>
    <span class="n">labels</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;solvent&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;water&quot;</span><span class="p">},</span>
        <span class="s2">&quot;solute&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;salt&quot;</span><span class="p">}</span>
    <span class="p">},</span>
    <span class="n">training_data</span><span class="o">=</span><span class="p">[</span><span class="n">data_source</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="simple-mixture-predictor">
<h2><span class="section-number">4.4.8. </span>Simple mixture predictor<a class="headerlink" href="#simple-mixture-predictor" title="Permalink to this headline"></a></h2>
<p>Formulations may contain ingredients that are blends of other ingredients.
Along the lines of the example above, hypertonic saline can be mixed with water to form isotonic saline.
Often, the properties of a hierarchical mixture are strongly associated with its leaf ingredients.
The <a class="reference internal" href="../reference/citrine.informatics.predictors.simple_mixture_predictor.html#citrine.informatics.predictors.simple_mixture_predictor.SimpleMixturePredictor" title="citrine.informatics.predictors.simple_mixture_predictor.SimpleMixturePredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleMixturePredictor</span></code></a>
flattens a hierarchical recipe into a recipe that contains only those leaf ingredients.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">input_descriptor</span></code> with key ‘Formulation’ is automatically generated that refers to the formulation to be flattened;
the associated material history of the input formulation is traversed to determine the leaf ingredients.
These leaf ingredients are then summed across all leaves of the mixing processes,
with the resulting candidates described by an automatically generated <code class="docutils literal notranslate"><span class="pre">output_descriptor</span></code> formulation descriptor named ‘Flat Formulation’.
The <code class="docutils literal notranslate"><span class="pre">training_data</span></code> parameter is used as a source of formulation recipes to be used in flattening hierarchical mixtures.</p>
<p>The following example illustrates how a <a class="reference internal" href="../reference/citrine.informatics.predictors.simple_mixture_predictor.html#citrine.informatics.predictors.simple_mixture_predictor.SimpleMixturePredictor" title="citrine.informatics.predictors.simple_mixture_predictor.SimpleMixturePredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleMixturePredictor</span></code></a>
can be used to flatten the ingredients used in aqueous dilutions of hypertonic saline,
yielding just the quantities of the leaf constituents salt and water.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">SimpleMixturePredictor</span>

<span class="c1"># table with simple mixtures and their ingredients</span>
<span class="n">data_source</span> <span class="o">=</span> <span class="n">GemTableDataSource</span><span class="p">(</span>
    <span class="n">table_id</span><span class="o">=</span><span class="n">table_uid</span><span class="p">,</span>
    <span class="n">table_version</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="n">SimpleMixturePredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Simple mixture predictor&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Constructs a formulation descriptor that flattens a hierarchy of simple mixtures into the quantities of leaf ingredients&#39;</span><span class="p">,</span>
    <span class="n">training_data</span><span class="o">=</span><span class="p">[</span><span class="n">data_source</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="mean-property-predictor">
<h2><span class="section-number">4.4.9. </span>Mean property predictor<a class="headerlink" href="#mean-property-predictor" title="Permalink to this headline"></a></h2>
<p>Often, properties of a mixture are proportional to the properties of its ingredients.
For example, the density of a saline solution can be computed from the densities of water and salt multiplied by their respective amounts:</p>
<div class="math notranslate nohighlight">
\[d_{saline} = d_{water} * f_{water} + d_{salt} * f_{salt}\]</div>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is density and <span class="math notranslate nohighlight">\(f\)</span> is relative ingredient fraction.
If the densities of water and salt are known, we can compute the expected density of a candidate mixture using this predictor.</p>
<p>The <a class="reference internal" href="../reference/citrine.informatics.predictors.mean_property_predictor.html#citrine.informatics.predictors.mean_property_predictor.MeanPropertyPredictor" title="citrine.informatics.predictors.mean_property_predictor.MeanPropertyPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanPropertyPredictor</span></code></a> computes mean properties of formulation ingredients.
For real-valued properties, a quantity-weighted mean value is computed.
For categorical-valued properties, a quantity-weighted distribution of property values is computed.
To configure a mean property predictor, we must specify:</p>
<ul class="simple">
<li><p>An input descriptor that holds the mixture’s recipe and ingredient labels</p></li>
<li><p>A list of properties to featurize (which may be either real or categorical)</p></li>
<li><p>The power of the quantity-weighted mean.
Positive, negative, and fractional powers are supported.
<code class="docutils literal notranslate"><span class="pre">p=1</span></code> corresponds to an arithmetic mean, which weights all quantities evenly.
Higher powers, such as <code class="docutils literal notranslate"><span class="pre">p=2</span></code>, place more weight on the property values of
components present at greater quantities in the mixture.
Negative powers place more weight on the property values of components with smaller quantities.</p></li>
<li><p>A data source that contains all ingredients and their properties</p></li>
<li><p>How to handle missing ingredient properties</p></li>
</ul>
<p>An optional label may also be specified if the mean should only be computed over ingredients given a specific label.</p>
<p>Missing ingredient properties can be handled one of three ways:</p>
<ol class="arabic simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">impute_properties</span> <span class="pre">==</span> <span class="pre">False</span></code>, all ingredients must define a value for all featurized properties.
Otherwise, the row will not be featurized.
Use this option if you expect ingredient properties to be dense (always present) and would like to exclude rows when properties are missing.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">impute_properties</span> <span class="pre">==</span> <span class="pre">True</span></code> and no <code class="docutils literal notranslate"><span class="pre">default_properties</span></code> are specified,
missing properties will be filled in using the average value across the entire dataset.
For real-valued properties this average is the mean over the training data,
while for categorical-valued properties it is the distribution of property values in the dataset.
The average is computed from any row with data corresponding to the missing property,
regardless of label or material type (i.e., the average is computed from all leaf ingredients and mixtures).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">impute_properties</span> <span class="pre">==</span> <span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">default_properties</span></code> are specified,
the specified property value will be used when an ingredient property is missing (instead of the average over the dataset).
This allows complete control over what values are imputed.
Default properties cannot be specified if <code class="docutils literal notranslate"><span class="pre">impute_properties</span> <span class="pre">==</span> <span class="pre">False</span></code> (because missing properties are not filled in).</p></li>
</ol>
<p>For example, say we add boric acid (a common antiseptic) as a possible ingredient to a saline solution,
but do not know its density (a real-valued property) or its solubility in acetone (a categorical-valued property).
Our leaf ingredient data might resemble:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 31%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Ingredient ID</p></th>
<th class="head"><p>Density (g/cc)</p></th>
<th class="head"><p>Acetone Solubility</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>water</p></td>
<td><p>1.0</p></td>
<td><p>Soluble</p></td>
</tr>
<tr class="row-odd"><td><p>salt</p></td>
<td><p>2.16</p></td>
<td><p>Insoluble</p></td>
</tr>
<tr class="row-even"><td><p>boric acid</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
</tr>
</tbody>
</table>
<p>If <code class="docutils literal notranslate"><span class="pre">impute_properties</span> <span class="pre">==</span> <span class="pre">False</span></code>, any mixture that includes boric acid will not be featurized.
If <code class="docutils literal notranslate"><span class="pre">impute_properties</span> <span class="pre">==</span> <span class="pre">True</span></code> and no <code class="docutils literal notranslate"><span class="pre">default_properties</span></code> are specified,
a mean density of <span class="math notranslate nohighlight">\(\left( 1.0 + 2.16 \right) / 2 = 1.58\)</span>
and a distribution of acetone solubility with weights <code class="docutils literal notranslate"><span class="pre">{'Soluble':</span> <span class="pre">0.5,</span> <span class="pre">'Insoluble':</span> <span class="pre">0.5}</span></code> will be used.
If something other than the imputed values should be used (e.g., 2.0 or ‘Slightly Soluble’),
this can be specified by setting <code class="docutils literal notranslate"><span class="pre">default_properties</span> <span class="pre">=</span> <span class="pre">{'density':</span> <span class="pre">2.0,</span> <span class="pre">'acetone</span> <span class="pre">solubility':</span> <span class="pre">'Slightly</span> <span class="pre">Soluble'}</span></code>.</p>
<p>The example below shows how to configure a mean property predictor
to compute the mean solute density and the distribution of acetone solubility in a formulation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.data_sources</span> <span class="kn">import</span> <span class="n">GemTableDataSource</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.descriptors</span> <span class="kn">import</span> <span class="n">FormulationDescriptor</span><span class="p">,</span> <span class="n">RealDescriptor</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">MeanPropertyPredictor</span>

<span class="c1"># descriptor that holds formulation data</span>
<span class="n">formulation</span> <span class="o">=</span> <span class="n">FormulationDescriptor</span><span class="o">.</span><span class="n">hierarchical</span><span class="p">()</span>

<span class="c1"># property descriptor to featurize</span>
<span class="n">density</span> <span class="o">=</span> <span class="n">RealDescriptor</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;g/cm^3&#39;</span><span class="p">)</span>
<span class="n">acetone_solubility</span> <span class="o">=</span> <span class="n">CategoricalDescriptor</span><span class="p">(</span>
    <span class="n">key</span><span class="o">=</span><span class="s1">&#39;acetone solubility&#39;</span><span class="p">,</span> <span class="n">categories</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Soluble&#39;</span><span class="p">,</span> <span class="s1">&#39;Insoluble&#39;</span><span class="p">,</span> <span class="s1">&#39;Slightly Soluble&#39;</span><span class="p">}</span>
<span class="p">)</span>

<span class="c1"># table with formulations and their ingredients</span>
<span class="n">data_source</span> <span class="o">=</span> <span class="n">GemTableDataSource</span><span class="p">(</span>
    <span class="n">table_id</span><span class="o">=</span><span class="n">table_uid</span><span class="p">,</span>
    <span class="n">table_version</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="n">mean_property_predictor</span> <span class="o">=</span> <span class="n">MeanPropertyPredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Mean property predictor&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Computes 1-weighted ingredient properties&#39;</span><span class="p">,</span>
    <span class="n">input_descriptor</span><span class="o">=</span><span class="n">formulation</span><span class="p">,</span>
    <span class="c1"># featurize ingredient density and acetone solubility</span>
    <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="n">density</span><span class="p">,</span> <span class="n">acetone_solubility</span><span class="p">],</span>
    <span class="c1"># compute the response with component quantities weighted evenly</span>
    <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">training_data</span><span class="o">=</span><span class="p">[</span><span class="n">data_source</span><span class="p">],</span>
    <span class="c1"># impute ingredient properties, if missing</span>
    <span class="n">impute_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># if missing, use provided defaults</span>
    <span class="n">default_properties</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;density&#39;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="s1">&#39;acetone solubility&#39;</span><span class="p">:</span> <span class="s1">&#39;Slightly Soluble&#39;</span><span class="p">},</span>
    <span class="c1"># only featurize ingredients labeled as a solute</span>
    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;solute&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This predictor will compute a real descriptor with a key  <code class="docutils literal notranslate"><span class="pre">mean</span> <span class="pre">of</span> <span class="pre">property</span> <span class="pre">density</span> <span class="pre">with</span> <span class="pre">label</span> <span class="pre">solute</span> <span class="pre">in</span> <span class="pre">formulation</span></code>
and a categorical descriptor with key <code class="docutils literal notranslate"><span class="pre">distribution</span> <span class="pre">of</span> <span class="pre">property</span> <span class="pre">acetone</span> <span class="pre">solubility</span> <span class="pre">with</span> <span class="pre">label</span> <span class="pre">solute</span> <span class="pre">in</span> <span class="pre">formulation</span></code>,
which can be retrieved using:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mean_property_descriptors</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">descriptors</span><span class="o">.</span><span class="n">from_predictor_responses</span><span class="p">(</span>
    <span class="n">predictor</span><span class="o">=</span><span class="n">mean_property_predictor</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">formulation_descriptor</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">p</span></code> is given a value other than <code class="docutils literal notranslate"><span class="pre">1</span></code>, that value will be included in the key for the feature
(e.g., <code class="docutils literal notranslate"><span class="pre">2.0-mean</span> <span class="pre">of</span> <span class="pre">property</span> <span class="pre">viscosity</span></code> or <code class="docutils literal notranslate"><span class="pre">2.0-weighted</span> <span class="pre">distribution</span> <span class="pre">of</span> <span class="pre">property</span> <span class="pre">color</span></code>).</p>
</section>
<section id="ingredient-fractions-predictor">
<h2><span class="section-number">4.4.10. </span>Ingredient fractions predictor<a class="headerlink" href="#ingredient-fractions-predictor" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../reference/citrine.informatics.predictors.ingredient_fractions_predictor.html#citrine.informatics.predictors.ingredient_fractions_predictor.IngredientFractionsPredictor" title="citrine.informatics.predictors.ingredient_fractions_predictor.IngredientFractionsPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">IngredientFractionsPredictor</span></code></a> featurizes ingredient fractions in a formulation.
The predictor is configured by specifying a descriptor that contains formulation data and a list of known ingredients to featurize.
The list of ingredients should be the list of all possible ingredients for the input mixture.
If the mixture contains an ingredient that wasn’t specified when the predictor was created, an error will be thrown.</p>
<p>For each featurized ingredient, the predictor will inspect the recipe and compute a response equal to the ingredient’s total fraction in the recipe.
If an ingredient is not present in the mixture’s recipe, the response for that ingredient fraction will be 0.
For example, given a formulation descriptor with key “formulation”, a recipe <code class="docutils literal notranslate"><span class="pre">{'water':</span> <span class="pre">0.9,</span> <span class="pre">'salt':</span> <span class="pre">0.1}</span></code>, and ingredients <code class="docutils literal notranslate"><span class="pre">['water',</span> <span class="pre">'salt',</span> <span class="pre">'boric</span> <span class="pre">acid']</span></code>,
this predictor would compute outputs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">water</span> <span class="pre">share</span> <span class="pre">in</span> <span class="pre">formulation</span> <span class="pre">==</span> <span class="pre">0.9</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">salt</span> <span class="pre">share</span> <span class="pre">in</span> <span class="pre">formulation</span> <span class="pre">==</span> <span class="pre">0.1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">boric</span> <span class="pre">acid</span> <span class="pre">share</span> <span class="pre">in</span> <span class="pre">formulation</span> <span class="pre">==</span> <span class="pre">0.0</span></code></p></li>
</ul>
<p>The example below shows how to configure an <code class="docutils literal notranslate"><span class="pre">IngredientFractionsPredictor</span></code> that computes these responses.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">IngredientFractionsPredictor</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.descriptors</span> <span class="kn">import</span> <span class="n">FormulationDescriptor</span>

<span class="n">formulation_descriptor</span> <span class="o">=</span> <span class="n">FormulationDescriptor</span><span class="o">.</span><span class="n">hierarchical</span><span class="p">()</span>

<span class="n">ingredient_fractions</span> <span class="o">=</span> <span class="n">IngredientFractionsPredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Ingredient Fractions Predictor&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Computes fractions of provided ingredients&#39;</span><span class="p">,</span>
    <span class="n">input_descriptor</span><span class="o">=</span><span class="n">formulation_descriptor</span><span class="p">,</span>
    <span class="n">ingredients</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">,</span> <span class="s1">&#39;salt&#39;</span><span class="p">,</span> <span class="s1">&#39;boric acid&#39;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The response descriptors can be retrieved using:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ingredient_fraction_descriptors</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">descriptors</span><span class="o">.</span><span class="n">from_predictor_responses</span><span class="p">(</span>
    <span class="n">predictor</span><span class="o">=</span><span class="n">ingredient_fractions</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">formulation_descriptor</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This will return a real descriptor for each featurized ingredient with bounds <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code> and key in the form <code class="docutils literal notranslate"><span class="pre">'{ingredient}</span> <span class="pre">share</span> <span class="pre">in</span> <span class="pre">{formulation</span> <span class="pre">key}'</span></code>
where <code class="docutils literal notranslate"><span class="pre">`{formulation</span> <span class="pre">key}`</span></code> is “formulation” and <code class="docutils literal notranslate"><span class="pre">{ingredient}</span></code> is either <code class="docutils literal notranslate"><span class="pre">water</span></code>, <code class="docutils literal notranslate"><span class="pre">salt</span></code> or <code class="docutils literal notranslate"><span class="pre">boric</span> <span class="pre">acid</span></code>.</p>
</section>
<section id="label-fractions-predictor">
<h2><span class="section-number">4.4.11. </span>Label fractions predictor<a class="headerlink" href="#label-fractions-predictor" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../reference/citrine.informatics.predictors.label_fractions_predictor.html#citrine.informatics.predictors.label_fractions_predictor.LabelFractionsPredictor" title="citrine.informatics.predictors.label_fractions_predictor.LabelFractionsPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelFractionsPredictor</span></code></a> computes total fraction of ingredients with a given label.
The predictor is configured by specifying either the flat or hierarchical formulation descriptor
that holds formulation data (i.e., recipes and ingredient labels) and a set of labels to featurize.
A separate response is computed for each featurized label by summing all quantities in the recipe associated with ingredients given the label.</p>
<p>The following example demonstrates how to create a predictor that computes the total fractions of solute and solvent in a formulation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine.informatics.descriptors</span> <span class="kn">import</span> <span class="n">FormulationDescriptor</span>
<span class="c1"># descriptor that holds formulation data</span>
<span class="n">formulation_descriptor</span> <span class="o">=</span> <span class="n">FormulationDescriptor</span><span class="o">.</span><span class="n">flat</span><span class="p">()</span>

<span class="n">label_fractions</span> <span class="o">=</span> <span class="n">LabelFractionsPredictor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Saline solution label fractions&#39;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Computes total fraction of solute and solvent&#39;</span><span class="p">,</span>
    <span class="n">input_descriptor</span><span class="o">=</span><span class="n">formulation_descriptor</span><span class="p">,</span>
    <span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;solute&#39;</span><span class="p">,</span> <span class="s1">&#39;solvent&#39;</span><span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This predictor will compute 2 responses, <code class="docutils literal notranslate"><span class="pre">solute</span> <span class="pre">share</span> <span class="pre">in</span> <span class="pre">formulation</span></code> and <code class="docutils literal notranslate"><span class="pre">solvent</span> <span class="pre">share</span> <span class="pre">in</span> <span class="pre">formulation</span></code>, which can be retrieved using:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">label_fractions_descriptors</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">descriptors</span><span class="o">.</span><span class="n">from_predictor_responses</span><span class="p">(</span>
    <span class="n">predictor</span><span class="o">=</span><span class="n">label_fractions</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">formulation_descriptor</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="simple-ml-predictor">
<h2><span class="section-number">4.4.12. </span>Simple ML predictor<a class="headerlink" href="#simple-ml-predictor" title="Permalink to this headline"></a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Simple ML Predictors are not supported on the Web UI and will be deprecated as of v2.0.
For analogous behavior use the build_simple_ml method to construct a Graph Predictor.
Use the convert_and_update (<a class="reference external" href="https://github.com/CitrineInformatics/citrine-python/blob/main/src/citrine/resources/predictor.py#L193">source</a>).
method to convert existing Simple ML Predictors to Graph Predictors.</p>
</div>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleMLPredictor</span></code> predicts material properties using a machine-learned model.
Each predictor is defined by a set of inputs, outputs, and latent variables.
Inputs are used as input features to the machine learning model.
Outputs are the properties that you would like the model to predict.
There must be at least one input and one output.
Latent variables are properties that you would like the model to predict and you think could also be useful in predicting the outputs.
If defined, latent variables are used to build hierarchical models.
One model is trained from inputs to latent variables, and another is trained from inputs and latent variables to outputs.
Thus, all inputs and latent variables are used to predict outputs.</p>
<p>Models are trained using data provided by a <a class="reference internal" href="../reference/citrine.informatics.data_sources.html#citrine.informatics.data_sources.DataSource" title="citrine.informatics.data_sources.DataSource"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataSource</span></code></a> specified when creating a predictor.</p>
<p>The following example demonstrates how to use the python SDK to create a <code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleMLPredictor</span></code>, register the predictor to a project and wait for validation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine</span> <span class="kn">import</span> <span class="n">Citrine</span>
<span class="kn">from</span> <span class="nn">citrine.seeding.find_or_create</span> <span class="kn">import</span> <span class="p">(</span><span class="n">find_or_create_project</span><span class="p">,</span>
                                            <span class="n">create_or_update</span>
                                           <span class="p">)</span>
<span class="kn">from</span> <span class="nn">citrine.jobs.waiting</span> <span class="kn">import</span> <span class="n">wait_while_validating</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">SimpleMLPredictor</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.data_sources</span> <span class="kn">import</span> <span class="n">GemTableDataSource</span>

<span class="c1"># create a session with citrine using your API key</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Citrine</span><span class="p">(</span><span class="n">api_key</span><span class="o">=</span><span class="n">API_KEY</span><span class="p">)</span>

<span class="c1"># find project by name &#39;Example project&#39; or create it if not found</span>
<span class="n">project</span> <span class="o">=</span> <span class="n">find_or_create_project</span><span class="p">(</span><span class="n">project_collection</span><span class="o">=</span><span class="n">session</span><span class="o">.</span><span class="n">projects</span><span class="p">,</span>
                                 <span class="n">project_name</span><span class="o">=</span><span class="s1">&#39;Example project&#39;</span>
                                <span class="p">)</span>

<span class="c1"># create SimpleMLPredictor (assumes descriptors for</span>
<span class="c1"># inputs/outputs/latent variables have already been created)</span>
<span class="n">simple_ml_predictor</span> <span class="o">=</span> <span class="n">SimpleMLPredictor</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Predictor name&#39;</span><span class="p">,</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;Predictor description&#39;</span><span class="p">,</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_descriptor_1</span><span class="p">,</span> <span class="n">input_descriptor_2</span><span class="p">],</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_descriptor_1</span><span class="p">,</span> <span class="n">output_descriptor_2</span><span class="p">],</span>
    <span class="n">latent_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">latent_variable_descriptor_1</span><span class="p">],</span>
    <span class="n">training_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">GemTableDataSource</span><span class="p">(</span><span class="n">table_id</span><span class="o">=</span><span class="n">training_data_table_uid</span><span class="p">,</span> <span class="n">table_version</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
<span class="p">)</span>

<span class="c1"># register predictor or update predictor of same name if it already</span>
<span class="c1"># exists in the project.</span>
<span class="n">predictor</span> <span class="o">=</span> <span class="n">create_or_update</span><span class="p">(</span><span class="n">collection</span><span class="o">=</span><span class="n">project</span><span class="o">.</span><span class="n">predictors</span><span class="p">,</span>
                             <span class="n">resource</span><span class="o">=</span><span class="n">simple_ml_predictor</span>
                            <span class="p">)</span>

<span class="c1"># wait while the predictor is validating and print status information</span>
<span class="c1"># while waiting.</span>
<span class="n">predictor</span> <span class="o">=</span> <span class="n">wait_while_validating</span><span class="p">(</span><span class="n">collection</span><span class="o">=</span><span class="n">project</span><span class="o">.</span><span class="n">predictors</span><span class="p">,</span>
                                  <span class="n">module</span><span class="o">=</span><span class="n">predictor</span><span class="p">,</span>
                                  <span class="n">print_status_info</span><span class="o">=</span><span class="kc">True</span>
                                 <span class="p">)</span>
</pre></div>
</div>
<p>Often, a <code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleMLPredictor</span></code> will include outputs from other predictors as inputs to its model.
Instead of entering these manually, outputs from a predictor can be retrieved programmatically using <code class="docutils literal notranslate"><span class="pre">outputs</span> <span class="pre">=</span> <span class="pre">project.descriptors.from_predictor_responses(predictor,</span> <span class="pre">inputs)</span></code>, where <code class="docutils literal notranslate"><span class="pre">outputs</span></code> is the list of descriptors returned by the <code class="docutils literal notranslate"><span class="pre">predictor</span></code> given a list of descriptors as <code class="docutils literal notranslate"><span class="pre">inputs</span></code>.</p>
<p>The following demonstrates how to create an <a class="reference internal" href="../reference/citrine.informatics.predictors.ingredient_fractions_predictor.html#citrine.informatics.predictors.ingredient_fractions_predictor.IngredientFractionsPredictor" title="citrine.informatics.predictors.ingredient_fractions_predictor.IngredientFractionsPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">IngredientFractionsPredictor</span></code></a> and use its outputs as inputs to a <code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleMLPredictor</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">citrine</span> <span class="kn">import</span> <span class="n">Citrine</span>
<span class="kn">from</span> <span class="nn">citrine.seeding.find_or_create</span> <span class="kn">import</span> <span class="n">find_or_create_project</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">SimpleMLPredictor</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.data_sources</span> <span class="kn">import</span> <span class="n">GemTableDataSource</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.predictors</span> <span class="kn">import</span> <span class="n">IngredientFractionsPredictor</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.descriptors</span> <span class="kn">import</span> <span class="n">FormulationDescriptor</span>

<span class="c1"># create a session with citrine using your API key</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Citrine</span><span class="p">(</span><span class="n">api_key</span><span class="o">=</span><span class="n">API_KEY</span><span class="p">)</span>

<span class="c1"># find project by name &#39;Example project&#39; or create it if not found</span>
<span class="n">project</span> <span class="o">=</span> <span class="n">find_or_create_project</span><span class="p">(</span><span class="n">project_collection</span><span class="o">=</span><span class="n">session</span><span class="o">.</span><span class="n">projects</span><span class="p">,</span>
                                 <span class="n">project_name</span><span class="o">=</span><span class="s1">&#39;Example project&#39;</span>
                                <span class="p">)</span>

<span class="c1"># create a descriptor to store formulations</span>
<span class="n">formulation_descriptor</span> <span class="o">=</span> <span class="n">FormulationDescriptor</span><span class="o">.</span><span class="n">flat</span><span class="p">()</span>

<span class="c1"># create a predictor that computes ingredient fractions</span>
<span class="n">ingredient_fractions</span> <span class="o">=</span> <span class="n">IngredientFractionsPredictor</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Ingredient Fractions Predictor&#39;</span><span class="p">,</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;Computes fractions of provided ingredients&#39;</span><span class="p">,</span>
    <span class="n">input_descriptor</span> <span class="o">=</span> <span class="n">formulation_descriptor</span><span class="p">,</span>
    <span class="n">ingredients</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">,</span> <span class="s1">&#39;salt&#39;</span><span class="p">,</span> <span class="s1">&#39;boric acid&#39;</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1"># get the descriptors the ingredient fractions predictor returns given the formulation descriptor</span>
<span class="n">ingredient_fraction_descriptors</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">descriptors</span><span class="o">.</span><span class="n">from_predictor_responses</span><span class="p">(</span>
    <span class="n">predictor</span><span class="o">=</span><span class="n">ingredient_fractions</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">formulation_descriptor</span><span class="p">]</span>
<span class="p">)</span>
<span class="c1"># ^^ in this case, ingredient_fraction_descriptors will contain 3 real descriptors: one for each featurized ingredient</span>

<span class="n">simple_ml_predictor</span> <span class="o">=</span> <span class="n">SimpleMLPredictor</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Predictor name&#39;</span><span class="p">,</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;Predictor description&#39;</span><span class="p">,</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">ingredient_fraction_descriptors</span><span class="p">,</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_descriptor</span><span class="p">],</span>
    <span class="n">latent_variables</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">training_data</span> <span class="o">=</span> <span class="n">GemTableDataSource</span><span class="p">(</span>
        <span class="n">table_id</span><span class="o">=</span><span class="n">training_data_table_uid</span><span class="p">,</span>
        <span class="n">table_version</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="predictor-reports">
<h2><span class="section-number">4.4.13. </span>Predictor reports<a class="headerlink" href="#predictor-reports" title="Permalink to this headline"></a></h2>
<p>A <a class="reference internal" href="predictor_reports.html"><span class="doc">predictor report</span></a> describes a machine-learned model, for example its settings and what features are important to the model.
It does not include predictor evaluation metrics.
To learn more about predictor evaluation metrics, please see <a class="reference internal" href="predictor_evaluation_workflows.html"><span class="doc">PredictorEvaluationWorkflow</span></a>.</p>
</section>
<section id="training-data">
<h2><span class="section-number">4.4.14. </span>Training data<a class="headerlink" href="#training-data" title="Permalink to this headline"></a></h2>
<p>Training data are defined by a list of <a class="reference internal" href="data_sources.html"><span class="doc">data sources</span></a>.
When multiple data sources are specified, data from all sources is combined into a flattened list and deduplicated prior to training a predictor.
Deduplication is performed if a uid or identifier is shared between two or more rows.
The content of a deduplicated row will contain the union of data across all rows that share the same uid or at least 1 identifier.
An error will be thrown if two deduplicated rows contain different data for the same descriptor because it’s unclear which value should be used in the deduplicated row.</p>
<p>Deduplication is additive.
Given three rows with identifiers <code class="docutils literal notranslate"><span class="pre">[a]</span></code>, <code class="docutils literal notranslate"><span class="pre">[b]</span></code> and <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code>, deduplication will result in a single row with three identifiers (<code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code>) and the union of all data from these rows.
Care must be taken to ensure uids and identifiers aren’t shared across multiple data sources to avoid unwanted deduplication.</p>
<p>When using a <a class="reference internal" href="../reference/citrine.informatics.predictors.graph_predictor.html#citrine.informatics.predictors.graph_predictor.GraphPredictor" title="citrine.informatics.predictors.graph_predictor.GraphPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphPredictor</span></code></a>, training data provided by the graph predictor and all sub-predictors are combined into a single deduplicated list.
Each predictor is trained on the subset of the combined data that is valid for the model.
Note, data may come from sources defined by other sub-predictors in the graph.
Because training data are shared by all predictors in the graph, a data source does not need to be redefined by all sub-predictors that require it.
If all data sources required to train a predictor are specified elsewhere in the graph, the <code class="docutils literal notranslate"><span class="pre">training_data</span></code> parameter may be omitted.
If the graph contains a predictor that requires formulations data, e.g. a <a class="reference internal" href="../reference/citrine.informatics.predictors.simple_mixture_predictor.html#citrine.informatics.predictors.simple_mixture_predictor.SimpleMixturePredictor" title="citrine.informatics.predictors.simple_mixture_predictor.SimpleMixturePredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleMixturePredictor</span></code></a> or <a class="reference internal" href="../reference/citrine.informatics.predictors.mean_property_predictor.html#citrine.informatics.predictors.mean_property_predictor.MeanPropertyPredictor" title="citrine.informatics.predictors.mean_property_predictor.MeanPropertyPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeanPropertyPredictor</span></code></a>, any GEM Tables specified by the graph predictor that contain formulation data must provide a formulation descriptor,
and this descriptor must match the input formulation descriptor of the sub-predictors that require these data.</p>
</section>
<section id="single-predictions">
<h2><span class="section-number">4.4.15. </span>Single Predictions<a class="headerlink" href="#single-predictions" title="Permalink to this headline"></a></h2>
<p>Once a <a class="reference internal" href="../reference/citrine.informatics.predictors.predictor.html#citrine.informatics.predictors.predictor.Predictor" title="citrine.informatics.predictors.predictor.Predictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Predictor</span></code></a> has been trained, a one-off prediction may be made against it by using the <code class="xref py py-func docutils literal notranslate"><span class="pre">predict()</span></code> method.</p>
<p>This method accepts a <a class="reference internal" href="../reference/citrine.informatics.predictors.single_predict_request.html#citrine.informatics.predictors.single_predict_request.SinglePredictRequest" title="citrine.informatics.predictors.single_predict_request.SinglePredictRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglePredictRequest</span></code></a>, which is akin to a <a class="reference internal" href="design_workflows.html#design-candidate-anchor"><span class="std std-ref">DesignCandidate</span></a> that you can define and modify and is not persisted in the Citrine Platform. When building a <a class="reference internal" href="../reference/citrine.informatics.predictors.single_predict_request.html#citrine.informatics.predictors.single_predict_request.SinglePredictRequest" title="citrine.informatics.predictors.single_predict_request.SinglePredictRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglePredictRequest</span></code></a> note that only the material properties required to make a prediction (the “input” properties”) are required. Indeed, when making a prediction on a predictor using the <code class="xref py py-func docutils literal notranslate"><span class="pre">predict()</span></code> method, the system will automatically filter out any provided material properties that are not inputs to the predictor. The output of a call to <code class="docutils literal notranslate"><span class="pre">predict()</span></code> is a <a class="reference internal" href="../reference/citrine.informatics.predictors.single_prediction.html#citrine.informatics.predictors.single_prediction.SinglePrediction" title="citrine.informatics.predictors.single_prediction.SinglePrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglePrediction</span></code></a>, which is essentially the <a class="reference internal" href="../reference/citrine.informatics.predictors.single_predict_request.html#citrine.informatics.predictors.single_predict_request.SinglePredictRequest" title="citrine.informatics.predictors.single_predict_request.SinglePredictRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglePredictRequest</span></code></a> with all of the predicted properties of the material filled in with the predicted values.</p>
<p>Note that a <code class="docutils literal notranslate"><span class="pre">random_seed</span></code> may be provided to the <a class="reference internal" href="../reference/citrine.informatics.predictors.single_predict_request.html#citrine.informatics.predictors.single_predict_request.SinglePredictRequest" title="citrine.informatics.predictors.single_predict_request.SinglePredictRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglePredictRequest</span></code></a>. Providing a consistent <code class="docutils literal notranslate"><span class="pre">random_seed</span></code> across requests with the same inputs guantees consistent predictions.</p>
<p>The following is a simple example of several predictions based on a function that builds a list of prediction requests. This example retrieves 3 candidates from a prior design execution, updates them slightly, and makes new predictions with the updated inputs. Note that while this example uses existing an <a class="reference internal" href="design_workflows.html#design-candidate-anchor"><span class="std std-ref">DesignCandidate</span></a> as a convenience to build the update prediction requests, there is no requirement that a prediction request be related to an existing <a class="reference internal" href="design_workflows.html#design-candidate-anchor"><span class="std std-ref">DesignCandidate</span></a> – rather any arbitrary request can be made as long as the inputs satisfy the requirements of the predictor.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">citrine</span> <span class="kn">import</span> <span class="n">Citrine</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.predictors.single_predict_request</span> <span class="kn">import</span> <span class="n">SinglePredictRequest</span>
<span class="kn">from</span> <span class="nn">citrine.informatics.predictors.single_prediction</span> <span class="kn">import</span> <span class="n">SinglePrediction</span>

<span class="c1"># arbitrary example of building a list of requests</span>
<span class="k">def</span> <span class="nf">build_requests</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SinglePredictRequest</span><span class="p">]:</span>
  <span class="c1"># assuming some my_execution: DesignExecution</span>
  <span class="n">my_candidates</span> <span class="o">=</span> <span class="n">my_execution</span><span class="o">.</span><span class="n">candidates</span><span class="p">(</span><span class="n">per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
  <span class="n">rs</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">my_candidates</span><span class="p">):</span>
    <span class="n">my_candidate</span> <span class="o">=</span> <span class="n">c</span>
    <span class="n">my_candidate</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;Heat Treatment Time 1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">rs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SinglePredictRequest</span><span class="p">(</span>
        <span class="n">material_id</span> <span class="o">=</span> <span class="n">my_candidate</span><span class="o">.</span><span class="n">material_id</span><span class="p">,</span>
        <span class="n">identifiers</span> <span class="o">=</span> <span class="n">my_candidate</span><span class="o">.</span><span class="n">identifiers</span><span class="p">,</span>
        <span class="n">material</span> <span class="o">=</span> <span class="n">my_candidate</span><span class="o">.</span><span class="n">material</span><span class="p">,</span>
    <span class="p">))</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">break</span>
  <span class="k">return</span> <span class="n">rs</span>

<span class="c1"># retrieve the predictor you&#39;d like to use</span>
<span class="n">my_predictor</span> <span class="o">=</span> <span class="n">my_project</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">uid</span> <span class="o">=</span> <span class="n">PREDICTOR_ID</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;most_recent&quot;</span><span class="p">)</span>

<span class="c1"># Make a prediction for each request and print out relevant results</span>
<span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">build_requests</span><span class="p">():</span>
  <span class="n">my_prediction</span><span class="p">:</span> <span class="n">SinglePrediction</span> <span class="o">=</span> <span class="n">my_predictor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
  <span class="n">my_id</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">material_id</span>
  <span class="n">heat_treatment_time</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;Heat Treatment Time 1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span>
  <span class="n">predicted_tensile_strength</span> <span class="o">=</span> <span class="n">my_prediction</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;Tensile Strength&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span>
  <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">my_id</span><span class="si">}</span><span class="s2"> updated_time=</span><span class="si">{</span><span class="n">heat_treatment_time</span><span class="si">}</span><span class="s2"> strength=</span><span class="si">{</span><span class="n">predicted_tensile_strength</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="descriptors.html" class="btn btn-neutral float-left" title="4.2. Descriptors" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="design_spaces.html" class="btn btn-neutral float-right" title="4.5. Design Spaces" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Citrine Informatics.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>